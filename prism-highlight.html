<!--
@license
Copyright 2016 The Advanced REST Client authors
Licensed under the Apache License, Version 2.0 (the "License"); you may not
use this file except in compliance with the License. You may obtain a copy of
the License at
http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations under
the License.
-->
<script src="../prism/prism.js" data-manual=""></script>
<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../paper-button/paper-button.html">
<link rel="import" href="../paper-progress/paper-progress.html">
<link rel="import" href="../paper-styles/paper-styles.html">
<link rel="import" href="prism-styles.html">
<!--
`<prism-highlight>` Syntax highlighting via Prism

### Example
```
<prism-highlight id="c1" lang="markdown"></prism-highlight>
<script>
  document.querySelector('#c1').code = '# Test highlight';
</script>
```

The `lang` attribute is required and the component will not start parsing data without it.

### Styling
`<prism-highlight>` provides the following custom properties and mixins for styling:

Custom property | Description | Default
----------------|-------------|----------
`--prism-highlight` | Mixin applied to the element | `{}`
`--prism-highlight-code` | Mixin applied to the `<pre>` element | `{}`
`--prism-highlight-mark` | Background color for the `<mark>` element when using custom search | `--paper-orange-500`

@group UI Elements
@element prism-highlight
@demo demo/index.html
-->
<dom-module id="prism-highlight">
  <template>
    <style include="prism-styles">
    :host {
      display: block;
      @apply(--prism-highlight);
    }

    pre {
      -webkit-user-select: text;
      margin: 8px;
      @apply(--prism-highlight-code);
    }

    paper-progress {
      width: 100%;
    }

    .arc-search-mark.selected {
      background-color: var(--prism-highlight-mark, --paper-orange-500);
    }
    </style>
    <pre class="parsed-content"><code id="output" class="language-" on-tap="_handleLinks"></code></pre>
    <div hidden$="[[!hasMore]]">
      <paper-button raised on-tap="_loadNext">Show next [[maxRead]] lines</paper-button>
      <paper-button raised on-tap="_loadAll">Display all</paper-button>
    </div>
    <paper-progress indeterminate hidden$="[[!working]]"></paper-progress>
  </template>
  <script>
  (function() {
    'use strict';

    var _path;
    if (window.currentImport && window.currentImport.URL) {
      let url = window.currentImport.URL;
      let path = url.substr(url.indexOf('/', url.indexOf('/') + 2))
        .replace('prism-highlight.html', '');
      let lastDot = path.lastIndexOf('.');
      if (lastDot !== -1 && path.substr(lastDot + 1) === 'html') {
        // remove element file name path
        path = path.substr(0, path.lastIndexOf('/') + 1);
      }
      _path = path;
    }
    const importLocation = _path;
    _path = undefined;

    class PrismHighlight {
      beforeRegister() {
        this.is = 'prism-highlight';
        /**
         * Fired when the user clicked on a link.
         *
         * @event link
         * @param {String} url Clicked url
         */
        this.properties = {
          /**
           * A data to be highlighted and dispayed.
           */
          code: String,
          /**
           * Prism supported language.
           */
          lang: String,
          /**
           * A list of tokenized code.
           * It's a result of calling `Prism.tokenize` function.
           */
          tokenized: {
            type: Array,
            readOnly: true
          },
          /**
           * True if not all data has been displayed in the display.
           */
          hasMore: {
            type: Boolean,
            readOnly: true,
            computed: '_computeHasMore(tokenized)'
          },
          /**
           * A number of lined to display at once.
           * After the limit is reached the display will show "load next [maxRead] items" and
           * "load all" buttons.
           */
          maxRead: {
            type: Number,
            value: 500
          },
          // True when parsing code or tokens to HTML code.
          working: {
            type: Boolean,
            value: false,
            readOnly: true
          },

          // An element which should be searched for text.
          _textSearch: {
            type: HTMLElement,
            value: function() {
              return this.$.output;
            }
          }
        };
      }

      get observers() {
        return [
          '_highlight(code, lang)'
        ];
      }

      detached() {
        if (this.worker) {
          this.worker.terminate();
          this.worker.onmessage = null;
          this.worker.onerror = null;
          this.worker = null;
        }
      }
      /**
       * Hightligt the code.
       * @param {String} data The code to be highlighted
       * @param {String} mime Mime type to be used to recognize the language.
       */
      _highlight(data, mime) {
        this._setTokenized(undefined);
        this.$.output.innerHTML = '';
        var message = {
          'language': mime,
          'code': data,
          'payload': 'tokenize'
        };
        this._runWorker(message);
      }
      /**
       * Sends message to the hightligt worker if its already created.
       * If not, this will create worker and then post message.
       * @param {Objects} message An object to pass to the worker.
       */
      _runWorker(message) {
        this._setWorking(true);
        if (this.worker) {
          this.worker.postMessage(message);
          return;
        }
        this.worker = new Worker(importLocation + 'workers/prism-worker.js');
        this.worker.onmessage = this._onWorkerData.bind(this);
        this.worker.onerror = this._onWorkerError.bind(this);
        this.worker.postMessage(message);
      }

      _onWorkerData(e) {
        this._setWorking(false);
        switch (e.data.payload) {
          case 'tokenize':
            this._onTokenized(e.data.tokens);
            break;
          case 'stringify':
            this._display(e.data.html);
            break;
        }
      }

      _onWorkerError(e) {
        this._setWorking(false);
        console.error('Hightligt worker error', e);
        var html = `<arc-error-message>
    <p>${e.message}</p>
  </arc-error-message>`;
        this._display(html);
      }
      /**
       * Handler for worker function after code tokenization.
       *
       * @param {Array} tokens An array of tokens returnet by Prism.
       */
      _onTokenized(tokens) {
        this._setTokenized(tokens);
        this._loadNext();
      }

      /**
       * Display next tokens from `this.tokenized` list - up to `this.maxRead` elements.
       * If after running this function the `this.tokenized` array is empty it will be set to undefined.
       */
      _loadNext() {
        if (!this.tokenized || this.tokenized.length === 0) {
          return;
        }
        var tokens = this.splice('tokenized', 0, this.maxRead);
        var message = {
          'tokens': tokens,
          'payload': 'stringify'
        };
        this._runWorker(message);
        if (this.tokenized.length === 0) {
          this._setTokenized(undefined);
        }
      }

      _loadAll() {
        var tokens = this.tokenized;
        this._setTokenized(undefined);
        var message = {
          'tokens': tokens,
          'payload': 'stringify'
        };
        this._runWorker(message);
      }
      /**
       * Display a HTML code generated by Prism.
       * @param {String} html HTML code to be displayed.
       */
      _display(html) {
        this.$.output.innerHTML += html;
      }

      _computeHasMore(tokenized) {
        if (!tokenized || tokenized.length === 0) {
          return false;
        }
        return true;
      }

      _handleLinks(e) {
        var el = e.target;
        if (el.nodeName !== 'A') {
          return;
        }
        e.preventDefault();

        var url = el.href;
        this.fire('link', {
          url: url
        });
      }
    }
    Polymer(PrismHighlight);
  })();
  </script>
</dom-module>
